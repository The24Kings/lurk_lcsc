mod common;

use lurk_lcsc::PktMessage;
use lurk_lcsc::{Packet, Parser, PktType};

#[test]
fn test_packet_message_parse_and_serialize() {
    let stream = common::setup();
    let original_bytes: &[u8; 80] = &[
        0x01, 0x0d, 0x00, 0x52, 0x69, 0x6c, 0x65, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57,
        0x6f, 0x72, 0x6c, 0x64, 0x21,
    ];

    // Create a packet with known bytes
    let packet = Packet::new(&stream, PktType::MESSAGE, original_bytes);

    // Deserialize the packet into a PktMessage
    let message = PktMessage::deserialize(packet);

    // Serialize the message back into bytes
    let mut buffer: Vec<u8> = Vec::new();
    message
        .serialize(&mut buffer)
        .expect("Serialization failed");

    // Assert that the serialized bytes match the original
    assert_eq!(buffer, original_bytes);
}
